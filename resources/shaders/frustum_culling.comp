#version 430

layout( local_size_x = 32 ) in;


struct bbox
{
    vec4 point1;
    vec4 point2;
};


layout( push_constant ) uniform params 
{
  mat4 projView;
  bbox bb;
  uint instanceNumber;
} PushConstant;

layout(std430, binding = 0) buffer matrixBuffer 
{
    mat4 matrix[];
};

layout(std430, binding = 1) buffer Count
{
    uint instanceCount;
};

layout(std430, binding = 2) buffer visibleBuffer
{
    uint outputInd[];
};

void main() 
{
    uint idx = gl_GlobalInvocationID.x;
    if (idx < PushConstant.instanceNumber) 
    {
        vec4 box[8] = { PushConstant.bb.point1,
                        vec4(PushConstant.bb.point1[0], PushConstant.bb.point1[1], PushConstant.bb.point2[2], 1.0f),
                        vec4(PushConstant.bb.point1[0], PushConstant.bb.point2[1], PushConstant.bb.point1[2], 1.0f),
                        vec4(PushConstant.bb.point1[0], PushConstant.bb.point2[1], PushConstant.bb.point2[2], 1.0f),
                        vec4(PushConstant.bb.point2[0], PushConstant.bb.point1[1], PushConstant.bb.point1[2], 1.0f),
                        vec4(PushConstant.bb.point2[0], PushConstant.bb.point1[1], PushConstant.bb.point2[2], 1.0f),
                        vec4(PushConstant.bb.point2[0], PushConstant.bb.point2[1], PushConstant.bb.point1[2], 1.0f),
                            PushConstant.bb.point2};
        
        bool check_vision = false;


        for (int j = 0; j < 8; j++) 
        {
            vec4 bound = PushConstant.projView * matrix[idx] * box[j];
            bound /= bound.w;
            check_vision = check_vision 
                || (abs(bound[0]) <= 1.0 && abs(bound[1]) <= 1.0 
                    && bound[2] >= 0 && bound[2] <= 1.0);
        }


        int num;

        if (check_vision) 
        {
            uint num = atomicAdd(instanceCount, 1);
            outputInd[num] = idx;
        }
    }
}