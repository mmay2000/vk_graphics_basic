#version 430

layout(local_size_x = 32, local_size_y = 32) in;

const uint kLength = 23;
const uint kRadius = kLength/2;

float coeffs[kLength] = {   0.011109f, 0.024258f, 0.049174f, 0.092535f, 0.161651f, 0.262149f,
                            0.394652f, 0.551540f, 0.715545f, 0.861776f, 0.963493f, 1.000000f, 
                            0.963493f, 0.861776f, 0.715545f, 0.551540f, 0.394652f, 0.262149f,
                            0.161651f, 0.092535f, 0.049174f, 0.024258f, 0.011109f};

layout (r32f, binding = 0) uniform readonly  image2D srcImg;
layout (r32f, binding = 1) uniform writeonly image2D dstImg;
layout (rgba32f, binding = 2) uniform readonly image2D position;


shared float[32 + 2*kRadius][32 + 2*kRadius] ImagePart;


void singlePass(uvec2 idx, uvec2 lidx, uint pos, uvec2 dir) {
    float color = 0.f;
    float coeffsSum  = 0.0f;
    float depth = imageLoad(position, ivec2(idx)).z;
    for (int i = 0; i < kLength; i++)
    {
        float neighborhoodDepth = imageLoad(position, ivec2(idx.x + dir.x*(i-kRadius), idx.y + dir.y*(i-kRadius))).z;
        if (abs(neighborhoodDepth - depth) <= 0.1)
        {
            color += coeffs[i] * ImagePart[pos*dir.x + dir.y*(i+lidx.y)][pos*dir.y + dir.x*(i+lidx.x)];
            coeffsSum += coeffs[i];
        }
    }
    barrier();
    ImagePart[pos*dir.x + dir.y*(lidx.y + kRadius)][pos*dir.y + dir.x*(lidx.x + kRadius)] = color / coeffsSum;
}

void main()  {
    uvec2 idx = gl_GlobalInvocationID.xy;
    uvec2 lidx = gl_LocalInvocationID.xy;
    uvec2 wgDim = gl_WorkGroupSize.xy;
    ivec2 imgDim = imageSize(srcImg);

    if (idx.x < imgDim.x && idx.y < imgDim.y) {
        ImagePart[lidx.y + kRadius][lidx.x + kRadius] = imageLoad(srcImg, ivec2(idx)).r;
    
    if (lidx.x < kRadius) {
        
        if (idx.x - kRadius < 0) 
            ImagePart[lidx.y + kRadius][lidx.x] = 0.f;
        else
            ImagePart[lidx.y + kRadius][lidx.x] = imageLoad(srcImg, ivec2(idx.x - kRadius, idx.y)).r;

        
        if (lidx.y >= wgDim.y - kRadius) {
            if (idx.x - kRadius < 0 || idx.y + kRadius >= imgDim.y) 
                ImagePart[lidx.y + 2*kRadius][lidx.x] = 0.f;
            else
                ImagePart[lidx.y + 2*kRadius][lidx.x] = imageLoad(srcImg, ivec2(idx.x - kRadius, idx.y + kRadius)).r;
        }
    }
    
    if (lidx.y < kRadius) {
        
        if (idx.x - kRadius < 0 || idx.y - kRadius < 0) 
            ImagePart[lidx.y][lidx.x] = 0.f;
        else
            ImagePart[lidx.y][lidx.x] = imageLoad(srcImg, ivec2(idx.x - kRadius, idx.y - kRadius)).r;

        
        if (idx.y - kRadius < 0)  
            ImagePart[lidx.y][lidx.x + kRadius] = 0.f;
        else
            ImagePart[lidx.y][lidx.x + kRadius] = imageLoad(srcImg, ivec2(idx.x, idx.y - kRadius)).r;

        
        if (lidx.x >= wgDim.x - kRadius) {
            if (idx.x + kRadius >= imgDim.x || idx.y < kRadius) 
                ImagePart[lidx.y][lidx.x + 2*kRadius] = 0.f;
            else
                ImagePart[lidx.y][lidx.x + 2*kRadius] = imageLoad(srcImg, ivec2(idx.x + kRadius, idx.y - kRadius)).r;
        }
    } 
    
    if (lidx.x + kRadius >= wgDim.x) {
        if (idx.x + kRadius >= imgDim.x) 
            ImagePart[lidx.y + kRadius][lidx.x + 2*kRadius] = 0.f;
        else
            ImagePart[lidx.y + kRadius][lidx.x + 2*kRadius] = imageLoad(srcImg, ivec2(idx.x+ kRadius, idx.y)).r;

        
        if (lidx.y + kRadius >= wgDim.y) {
            if (idx.x + kRadius >= imgDim.x || idx.y + kRadius >= imgDim.y) 
                ImagePart[lidx.y + 2*kRadius][lidx.x + 2*kRadius] = 0.f;
            else
                ImagePart[lidx.y + 2*kRadius][lidx.x + 2*kRadius] = imageLoad(srcImg, ivec2(idx.x + kRadius, idx.y + kRadius)).r;
        }
    }

    if (lidx.y + kRadius >= wgDim.y) { 
        if (idx.y + kRadius >= imgDim.y) 
            ImagePart[lidx.y + 2*kRadius][lidx.x + kRadius] = 0.f;
        else
            ImagePart[lidx.y + 2*kRadius][lidx.x + kRadius] = imageLoad(srcImg, ivec2(idx.x, idx.y + kRadius)).r;
    }
        barrier();

        singlePass(idx, lidx, lidx.y + kRadius, uvec2(1, 0));

        
        if ((lidx.y < kRadius) && (idx.y >= kRadius))
            singlePass(idx, lidx, lidx.y, uvec2(1, 0));
        else if ((lidx.y >= wgDim.y - kRadius) && (idx.y + kRadius < imgDim.y))
            singlePass(idx, lidx, lidx.y + 2*kRadius, uvec2(1, 0));

        barrier();

        singlePass(idx, lidx, lidx.x + kRadius, uvec2(0, 1));

        imageStore(dstImg, ivec2(idx), vec4(ImagePart[lidx.y + kRadius][lidx.x + kRadius], 0.f, 0.f, 0.f));
    }
}